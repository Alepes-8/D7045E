<!-- @author Alex Peschel, Oliver Olofsson -->

<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
    <title>Laboration 3</title>

    <style>
        body {
            background-color: #ffffff;
        }
    </style>

    </script>
    <script src="gl_matrix.js"></script>
    <script src="Library/MV.js"></script>
    <script src="Classes/mesh.js"></script>
    <script src="Classes/shader.js"></script>
    <script src="Classes/shaderProgram.js"></script>
    <script src="Classes/matrial.js"></script>
    <script src="Classes/graphicsNode.js"></script>
    <script src="Classes/monochromeMaterial.js"></script>
    <script src="Shapes/cuboid.js"></script>
    <script src="Shapes/torus.js"></script>
    <script src="Shapes/cylinder.js"></script>
    <script src="Shapes/cone.js"></script>
    <script src="Shapes/sphere.js"></script>
    <script src="Shapes/star.js"></script>
    <script src="Objects/floor.js"></script>
    <script src="Objects/robot.js"></script>
    <script src="camera.js"></script>
    <script src="UserInputs/key.js"></script>
    <script src="UserInputs/changeObjects.js"></script>

    <script>
        //id vertex shader and id fragmen shader is the shaders we have
    
    const vertexShaderSource = `#version 300 es
        layout(location=0) in vec4 vertexPos;
        uniform mat4 cMatrix;
        uniform mat4 modelViewvMatrix;
        uniform mat4 perspectiveMatrix;
        uniform vec4 cameraPos;
        
        out float distance;

        void main()
        {
            gl_Position = perspectiveMatrix * modelViewvMatrix * cMatrix * vertexPos;
            distance = length((cMatrix * vertexPos) - cameraPos) ;
;
        }`;

    const fragmentShaderSource = `#version 300 es
        precision mediump float;
        uniform vec4 u_Color;
        in float distance;
        out vec4 fragColor;

        void main() {
            fragColor = vec4(u_Color.xyz * (10.0/(distance)),1);
        }`;
    
    let canvas;
    let gl;
    let nodes = [];
    let movingNode;
    let floor;
    let robot;
    let camera;
    let shader;
    let part = true;
    let centerNode;
    let test;

    function init() {

        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");

        if (!gl) {alert("WebGL isn't available");}

        //webgl configurations
        gl.viewport( 0, 0, canvas.width, canvas.height ); //delete
        gl.clearColor(0.2, 0.2, .2, 1 );

        gl.enable(gl.DEPTH_TEST);

        let fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        let vertexShader = new Shader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        shader = new ShaderProgram(gl, vertexShader.getter(), fragmentShader.getter());

        camera = new Camera(gl, shader.getProgram());

        optionListiners();

        //colors
        let monoBlue = new MonochromeMaterial(gl, vec4(0,1, 1, 1.0), shader);
        let monoNode = new MonochromeMaterial(gl, vec4(1.0, 0.0, 0, 1.0), shader);
        let monoBlack = new MonochromeMaterial(gl, vec4(0, 0, 0, 1.0), shader);
        let monoYellow = new MonochromeMaterial(gl, vec4(1, 1, 0, 1.0), shader);

        //shapes
        let cuboid1 = new Cuboid(gl, 0.5, 0.5, 0.5, shader.getProgram());
        let cuboid2 = new Cuboid(gl, 0.5, 0.5, 0.5, shader.getProgram());
        let torus = new Torus(gl, 1, 0.2, shader.getProgram());

        //Positions
        let center = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
        let extraTransform = mat4(1,0,0,3, 0,1,0,0, 0,0,1,2, 0,0,0,1);
        let boardPlacement = mat4(1,0,0,-4, 0,1,0,-2, 0,0,1,-4, 0,0,0,1);

        // changes to the poition, mostly rotation if needed.
        extraTransform = rotateObject(extraTransform)

        //creation of nodes
        centerNode = new GraphicsNode(gl, cuboid2, monoYellow, center ,monoBlack);
        movingNode = new GraphicsNode(gl, torus, monoYellow, extraTransform ,monoBlack,centerNode);
        test = new GraphicsNode(gl, torus, monoNode, extraTransform ,monoBlack,movingNode);
        
        //creation of objects
        floor = new Floor(16, 0.1,16, 8, 8, boardPlacement,monoBlue,monoNode, center);
        floor.createFloor(gl, shader);
        
        //store parts connected to the center
        nodes.push(movingNode);

        
        render();
    }

    function optionListiners(){
        let key = new Key();
        let changeObjects = new ChangeObjects();

        //buttons
        document.getElementById("persproj").checked = true;
        document.getElementById("mainForm").value = "1";
        document.getElementById("secoundaryForm").value = "1";
        document.getElementById("mainForm").onchange = changeObjects.mainNode;
        document.getElementById("mainwidth").onchange = changeObjects.mainNode;
        document.getElementById("mainheight").onchange = changeObjects.mainNode;
        document.getElementById("maindepth").onchange = changeObjects.mainNode;

        document.getElementById("secwidth").onchange = changeObjects.secoundChange;
        document.getElementById("secheight").onchange = changeObjects.secoundChange;
        document.getElementById("secdepth").onchange = changeObjects.secoundChange;

        document.getElementById("secoundaryForm").onchange = changeObjects.secoundChange;

        //camera
        document.getElementById("persproj").onchange = render;
        document.getElementById("orthproj").onchange = render; 
        
        //key input
        document.addEventListener('keydown', key.doKey, false);
    }
    
    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        shader.activate();
        camera.activate(document.getElementById("persproj").checked);

        floor.draw();

        centerNode.draw();
        //movingNode.draw();

        test.draw();

        for(let i = 0; i< nodes.length; i++){

            nodes[i].draw();
        }

    } 

    function addRotation(){
        let degree = 2;
        let rotation = rotate(degree, [0,1,0]);
        let matrix = mult( movingNode.transform, rotation);
        movingNode.localMatrix = matrix;
        movingNode.transform = mult(movingNode.localMatrix,movingNode.worldMatrix.transform)
    }

    function rotateWorld(degree){
        let rotation = rotate(degree, [0,1,0]);
        let matrix = mult( centerNode.transform, rotation);
        centerNode.localMatrix = matrix;
        centerNode.transform = matrix;

        let a = movingNode.transform[2][3];
        let b = movingNode.transform[0][3];
        let hyp = Math.sqrt(a*a + b*b);
        let angle = Math.atan(a/b) * (180/Math.PI);

        if(angle - degree < -90){
            angle = 90 + (angle -degree +90);
            if(b>0){
                b = -(hyp * Math.cos(angle * (Math.PI/180) ));
            }else{
                b = hyp * Math.cos(angle * (Math.PI/180) );
            }
        }
        else{
            angle -=degree;
        }

        if(b > 0){
            b = hyp * Math.cos(angle * (Math.PI/180) );
            a = hyp * Math.sin(angle * (Math.PI/180));
        }else{
            b = -(hyp * Math.cos(angle * (Math.PI/180) ));
            a = -(hyp * Math.sin(angle * (Math.PI/180)));
        }
        
        movingNode.localMatrix[2][3] = a;
        movingNode.localMatrix[0][3] = b;
        
    }

    function rotateObject(matrix){
        let a = matrix[2][3];
        let b = matrix[0][3];
        let hyp = Math.sqrt(a*a + b*b);
        let angle = Math.atan(a/b) * (180/Math.PI);
        let rotation = rotate(-angle,[0,1,0]);
        return mult(matrix, rotation);

    }


   
    window.onload = init;
    
</script>
</head>
<body>
        <h2>A Cube with Basic Lighting</h2>

    <p id=message>Use arrow keys, PageUp, and PageDown to rotate the cube.<br>
    Home or Return key resets rotations to zero.</p>

    <p>
    <label><input type="radio" name="projectionType" id="persproj" value="perspective">Perspective projection</label>
    <label><input type="radio" name="projectionType" id="orthproj" value="orthogonal" style="margin-left:1cm">Orthogonal projection</label>
    <label><b>Main form:</b>&nbsp;<select id="mainForm">
        <option value="1">square</option>
        <option value="2">sphere</option>
        <option value="3">cone</option>
        <option value="4">torus</option>
        <option value="5">cylinder</option>
        <option value="6">Star</option>

    </select></label>
    <label><b>width<input type="number"  id="mainwidth" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>height<input type="number"  id="mainheight" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>depth<input type="number" id="maindepth" value="0.5" min="0.1" step="0.1"></b></label> 
    <style>
        input {
            resize: horizontal;
            width: 40px;
        }
    </style>    

    <label><b>stastionary form: </b>&nbsp;<select id="secoundaryForm">
        <option value="0">random</option>
        <option value="1">square</option>
        <option value="2">sphere</option>
        <option value="3">cone</option>
        <option value="4">torus</option>
        <option value="5">cylinder</option>
        <option value="6">Star</option>


    </select></label>
    <label><b>width<input type="number"  id="secwidth" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>height<input type="number"  id="secheight" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>depth<input type="number"  id="secdepth" value="0.5" min="0.1" step="0.1"></b></label> 
    <style>
        input {
            resize: horizontal;
            width: 40px;
        }
    </style>    
    </p>

    <noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

    <div id="canvas-holder">
    <canvas width=1500px height=800px id="webglcanvas" style="background-color:rgb(0, 0, 0)"></canvas>
    </div>

</body>
</html>