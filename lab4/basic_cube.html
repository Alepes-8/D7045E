<!-- @author Alex Peschel, Oliver Olofsson -->

<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
    <title>Laboration 3</title>

    <style>
        body {
            background-color: #ffffff;
        }
    </style>

    </script>
    <script src="gl_matrix.js"></script>
    <script src="Library/MV.js"></script>
    <script src="Classes/mesh.js"></script>
    <script src="Classes/shader.js"></script>
    <script src="Classes/shaderProgram.js"></script>
    <script src="Classes/matrial.js"></script>
    <script src="Classes/graphicsNode.js"></script>
    <script src="Classes/monochromeMaterial.js"></script>
    <script src="Shapes/cuboid.js"></script>
    <script src="Shapes/torus.js"></script>
    <script src="Shapes/cylinder.js"></script>
    <script src="Shapes/cone.js"></script>
    <script src="Shapes/sphere.js"></script>
    <script src="Shapes/star.js"></script>
    <script src="Objects/floor.js"></script>
    <script src="Objects/robot.js"></script>
    <script src="camera.js"></script>
    <script src="UserInputs/key.js"></script>
    <script src="UserInputs/changeObjects.js"></script>

    <script>
        //id vertex shader and id fragmen shader is the shaders we have
    
    const vertexShaderSource = `#version 300 es
        layout(location=0) in vec4 vertexPos;
        uniform mat4 cMatrix;
        uniform mat4 modelViewvMatrix;
        uniform mat4 perspectiveMatrix;
        uniform vec4 cameraPos;
        
        out float distance;

        void main()
        {
            gl_Position = perspectiveMatrix * modelViewvMatrix * cMatrix * vertexPos;
            distance = length((cMatrix * vertexPos) - cameraPos) ;
;
        }`;

    const fragmentShaderSource = `#version 300 es
        precision mediump float;
        uniform vec4 u_Color;
        in float distance;
        out vec4 fragColor;

        void main() {
            fragColor = vec4(u_Color.xyz * (10.0/(distance)),1);
        }`;
    
    let canvas;
    let gl;
    let nodes = [];
    let movingNode;
    let camera;
    let shader;
    let centerNode;
    let itemArray = [];


    function init() {

        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");

        if (!gl) {alert("WebGL isn't available");}

        //webgl configurations
        gl.viewport( 0, 0, canvas.width, canvas.height ); //delete
        gl.clearColor(0.2, 0.2, .2, 1 );

        gl.enable(gl.DEPTH_TEST);

        let fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        let vertexShader = new Shader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        shader = new ShaderProgram(gl, vertexShader.getter(), fragmentShader.getter());

        camera = new Camera(gl, shader.getProgram());

        optionListiners();

        //init values
        let boardWeith = 20;
        let boardHight = 0.1;
        let boardLength = 20;
        let tilesX = 8;
        let tilesY = 8;
        let ballRadien = 3;
        let itemHights = 3;


        //colors
        let monoBlue = new MonochromeMaterial(gl, vec4(0,1, 1, 1.0), shader);
        let monoNode = new MonochromeMaterial(gl, vec4(1.0, 0.0, 0, 1.0), shader);
        let monoBlack = new MonochromeMaterial(gl, vec4(0, 0, 0, 1.0), shader);
        let monoWhite = new MonochromeMaterial(gl, vec4(1, 1, 1, 1.0), shader);
        let monoYellow = new MonochromeMaterial(gl, vec4(1, 1, 0, 1.0), shader);

        //shapes
        let center = new Sphere(gl, 0.5, shader.getProgram());
        let boardFirstSquare = new Cuboid(gl, boardWeith/tilesX, boardHight, boardLength/tilesY, shader.getProgram());
        let sphereForm = new Sphere(gl, ballRadien, shader.getProgram());
        let torus = new Torus(gl, 1, 0.2, shader.getProgram());
        let cone = new Cone(gl, 1, itemHights, shader.getProgram());
        let cube = new Cuboid(gl, 1, itemHights, 1, shader.getProgram());
        let cylinder = new Cylinder(gl, 1, itemHights, shader.getProgram());


        //Positions
        let centerTransform = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
        let firstBoardPiece = mat4(1,0,0,-((boardWeith/5) *2), 0,1,0,-2, 0,0,1,boardLength/2, 0,0,0,1);
        let ballTransform = mat4(1,0,0,0, 0,1,0,ballRadien/2, 0,0,1,0, 0,0,0,1);
        let torusTransform = mat4(1,0,0,0, 0,1,0,1, 0,0,1,0, 0,0,0,1);
        let cubeTransform = mat4(1,0,0,0, 0,1,0,itemHights/2, 0,0,1,0, 0,0,0,1);
        let coneTransform = mat4(1,0,0,0, 0,1,0,itemHights/2, 0,0,1,0, 0,0,0,1);
        let cylinderTransform = mat4(1,0,0,0, 0,1,0,itemHights/2, 0,0,1,0, 0,0,0,1);
        let testTransform = mat4(1,0,0,3, 0,1,0,0, 0,0,1,2, 0,0,0,1)
        let test2Transform = mat4(1,0,0,3, 0,1,0,0, 0,0,1,2, 0,0,0,1)



        //creation of center
        centerNode = new GraphicsNode(gl, center, monoYellow, centerTransform ,monoBlack);


        //store parts connected to the center
        nodes.push(new GraphicsNode(gl, boardFirstSquare, monoBlack, firstBoardPiece ,monoBlack,centerNode));
        nodes.push(new GraphicsNode(gl, sphereForm, monoYellow, ballTransform ,monoBlack,nodes[0]));

        //creation of objects
        floor = new Floor(boardWeith, boardHight,boardLength, tilesX, tilesY,monoWhite,monoBlack, nodes[0]);
        floor.createFloor(gl, shader);

        //creation of nodes
        itemArray.push(new GraphicsNode(gl, torus, monoYellow, torusTransform ,monoBlack,floor.movingNode[5]));
        itemArray.push(new GraphicsNode(gl, cone, monoYellow, coneTransform ,monoBlack,floor.movingNode[20]));
        itemArray.push(new GraphicsNode(gl, cube, monoYellow, cubeTransform ,monoBlack,floor.movingNode[40]));
        itemArray.push(new GraphicsNode(gl, cylinder, monoYellow, cylinderTransform ,monoBlack,floor.movingNode[50]));

        // changes to the poition, mostly rotation if needed.        
        addRotation(itemArray[0], 34, "y");

        rotateWorldY(-0.01);
        render(); 
    }

    function optionListiners(){
        let key = new Key();
        let changeObjects = new ChangeObjects();

        //buttons
        document.getElementById("persproj").checked = true;
        document.getElementById("mainForm").value = "1";
        document.getElementById("secoundaryForm").value = "1";
        document.getElementById("mainForm").onchange = changeObjects.mainNode;
        document.getElementById("mainwidth").onchange = changeObjects.mainNode;
        document.getElementById("mainheight").onchange = changeObjects.mainNode;
        document.getElementById("maindepth").onchange = changeObjects.mainNode;

        document.getElementById("secwidth").onchange = changeObjects.secoundChange;
        document.getElementById("secheight").onchange = changeObjects.secoundChange;
        document.getElementById("secdepth").onchange = changeObjects.secoundChange;

        document.getElementById("secoundaryForm").onchange = changeObjects.secoundChange;

        //camera
        document.getElementById("persproj").onchange = render;
        document.getElementById("orthproj").onchange = render; 
        
        //key input
        document.addEventListener('keydown', key.doKey, false);
    }
    
    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        shader.activate();
        camera.activate(document.getElementById("persproj").checked);

        centerNode.draw();

        for(let i = 0; i< nodes.length; i++){
            nodes[i].draw();
        } 

        floor.draw();

        for(let i = 0; i< itemArray.length; i++){
            itemArray[i].draw();
        } 

        
    } 

    function move(m){
        nodes[0].updateTransform(m);
    }

    function addRotation(object,degree, axes){
        object.transform = mult(object.localMatrix, object.worldMatrix.transform);
        let x = object.transform[0][3];
        let y = object.transform[1][3];
        let z = object.transform[2][3];

        object.transform[0][3] = 0;
        object.transform[1][3] = 0;
        object.transform[2][3] = 0;
        console.log("before", object.transform)

        if(axes == "x"){
            object.transform = mult(object.transform, rotate(degree,[1,0,0]));
        }else if(axes == "y"){
            object.transform = mult(object.transform, rotate(degree,[0,1,0]));
        }else if(axes == "z"){
            object.transform = mult(object.transform, rotate(degree,[0,0,1]));
        }
        console.log(object.transform)
        console.log(x,y,z)

        object.transform[0][3] = x;
        object.transform[1][3] = y;
        object.transform[2][3] = z;
        console.log("after adding x", object.transform)

        invMatrix = inverse4(object.worldMatrix.transform);
        object.localMatrix = mult(object.transform,invMatrix);
        console.log(object.localMatrix)
    }

    function forSpecificNodeY(object,degree){
        let a = object.localMatrix[2][3];
        let b = object.localMatrix[0][3];
        let hyp = Math.sqrt(a*a + b*b);
        let angle = Math.atan(a/b) * (180/Math.PI);
        if(a == 0 && b == 0){
            object.localMatrix[2][3] = 0;
            object.localMatrix[0][3] = 0;
        }else{
            if(angle - degree < -90){
                angle = 90 + (angle -degree +90);
                if(b>0){
                    b = -(hyp * Math.cos(angle * (Math.PI/180) ));
                }else{
                    b = hyp * Math.cos(angle * (Math.PI/180) );
                }
            }
            else{
                angle -=degree;
            }

            if(b > 0){
                b = hyp * Math.cos(angle * (Math.PI/180) );
                a = hyp * Math.sin(angle * (Math.PI/180));
            }else if(b==0){
                if(a > 0){
                    a = hyp * Math.sin(angle * (Math.PI/180));
                }
                if(a > 0){
                    a = -(hyp * Math.sin(angle * (Math.PI/180)));
                }
                b = (hyp * Math.cos(angle * (Math.PI/180) ));
            }
            else{
                b = -(hyp * Math.cos(angle * (Math.PI/180) ));
                a = -(hyp * Math.sin(angle * (Math.PI/180)));
            }
            object.localMatrix[2][3] = a;
            object.localMatrix[0][3] = b;
        }
        
       
        for(let j = 0; j < object.children.length; j++){
            forSpecificNodeY(object.children[j],degree);
        }
    }

    function rotateWorldY(degree){
        let rotation = rotate(degree, [0,1,0]);
        let matrix = mult( nodes[0].transform, rotation);
        nodes[0].localMatrix = matrix;
        
        for(let i = 0; i < nodes.length; i++){
            let item = nodes[i];
            let a = item.localMatrix[2][3];
            let b = item.localMatrix[0][3];
            let hyp = Math.sqrt(a*a + b*b);
            let angle = Math.atan(a/b) * (180/Math.PI);

           if(a == 0 && b==0){
               a=0;
               b=0;
            }else{
                if(angle - degree < -90){
                    angle = 90 + (angle -degree +90);
                    if(b>0){
                        b = -(hyp * Math.cos(angle * (Math.PI/180) ));
                    }else{
                        b = hyp * Math.cos(angle * (Math.PI/180) );
                    }
                }
                else{
                    angle -=degree;
                }

                if(b > 0){
                    b = hyp * Math.cos(angle * (Math.PI/180) );
                    a = hyp * Math.sin(angle * (Math.PI/180));
                }
                else if(b==0){
                    if(a > 0){
                        a = hyp * Math.sin(angle * (Math.PI/180));
                    }
                    if(a > 0){
                        a = -(hyp * Math.sin(angle * (Math.PI/180)));
                    }
                    b = -(hyp * Math.cos(angle * (Math.PI/180) ));
                }
                else{
                    b = -(hyp * Math.cos(angle * (Math.PI/180) ));
                    a = -(hyp * Math.sin(angle * (Math.PI/180)));
                }
           }
            
            item.localMatrix[2][3] = a;
            item.localMatrix[0][3] = b;
            for(let j = 0; j < item.children.length; j++){
                forSpecificNodeY(item.children[j],degree);
            }

        }
        
        
    }
/*
    function rotateObject(matrix){
        let a = matrix[2][3];
        let b = matrix[0][3];
        let hyp = Math.sqrt(a*a + b*b);
        let angle = Math.atan(a/b) * (180/Math.PI);
        let rotation = rotate(-angle,[0,1,0]);
        return mult(matrix, rotation);

    }
*/

   
    window.onload = init;
    
</script>
</head>
<body>
        <h2>A Cube with Basic Lighting</h2>

    <p id=message>Use arrow keys, PageUp, and PageDown to rotate the cube.<br>
    Home or Return key resets rotations to zero.</p>

    <p>
    <label><input type="radio" name="projectionType" id="persproj" value="perspective">Perspective projection</label>
    <label><input type="radio" name="projectionType" id="orthproj" value="orthogonal" style="margin-left:1cm">Orthogonal projection</label>
    <label><b>Main form:</b>&nbsp;<select id="mainForm">
        <option value="1">square</option>
        <option value="2">sphere</option>
        <option value="3">cone</option>
        <option value="4">torus</option>
        <option value="5">cylinder</option>
        <option value="6">Star</option>

    </select></label>
    <label><b>width<input type="number"  id="mainwidth" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>height<input type="number"  id="mainheight" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>depth<input type="number" id="maindepth" value="0.5" min="0.1" step="0.1"></b></label> 
    <style>
        input {
            resize: horizontal;
            width: 40px;
        }
    </style>    

    <label><b>stastionary form: </b>&nbsp;<select id="secoundaryForm">
        <option value="0">random</option>
        <option value="1">square</option>
        <option value="2">sphere</option>
        <option value="3">cone</option>
        <option value="4">torus</option>
        <option value="5">cylinder</option>
        <option value="6">Star</option>


    </select></label>
    <label><b>width<input type="number"  id="secwidth" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>height<input type="number"  id="secheight" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>depth<input type="number"  id="secdepth" value="0.5" min="0.1" step="0.1"></b></label> 
    <style>
        input {
            resize: horizontal;
            width: 40px;
        }
    </style>    
    </p>

    <noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

    <div id="canvas-holder">
    <canvas width=1500px height=800px id="webglcanvas" style="background-color:rgb(0, 0, 0)"></canvas>
    </div>

</body>
</html>