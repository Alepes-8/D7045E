<!-- @author Alex Peschel, Oliver Olofsson -->

<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
    <title>Laboration 3</title>

    <style>
        body {
            background-color: #ffffff;
        }
    </style>

    </script>
    <script src="gl_matrix.js"></script>
    <script src="Library/MV.js"></script>
    <script src="Classes/mesh.js"></script>
    <script src="Classes/shader.js"></script>
    <script src="Classes/shaderProgram.js"></script>
    <script src="Classes/matrial.js"></script>
    <script src="Classes/graphicsNode.js"></script>
    <script src="Classes/monochromeMaterial.js"></script>
    <script src="Shapes/cuboid.js"></script>
    <script src="Shapes/torus.js"></script>
    <script src="Shapes/cylinder.js"></script>
    <script src="Shapes/cone.js"></script>
    <script src="Shapes/sphere.js"></script>
    <script src="Shapes/star.js"></script>
    <script src="Objects/floor.js"></script>
    <script src="Objects/robot.js"></script>
    <script src="camera.js"></script>
    <script src="UserInputs/key.js"></script>
    <script src="UserInputs/changeObjects.js"></script>

    <script>
        //id vertex shader and id fragmen shader is the shaders we have
    
    const vertexShaderSource = `#version 300 es
        layout(location=0) in vec4 vertexPos;
        uniform mat4 cMatrix;
        uniform mat4 modelViewvMatrix;
        uniform mat4 perspectiveMatrix;
        uniform vec4 cameraPos;
        
        out float distance;

        void main()
        {
            gl_Position = perspectiveMatrix * modelViewvMatrix * cMatrix * vertexPos;
            distance = length((cMatrix * vertexPos) - cameraPos) ;
        }`;

    const fragmentShaderSource = `#version 300 es
        precision mediump float;
        uniform vec4 u_Color;
        in float distance;
        out vec4 fragColor;

        void main() {
            fragColor = vec4(u_Color.xyz * (10.0/(distance)),1);
        }`;
    
    let canvas;
    let gl;
    let camera;
    let shader;
    let part = true;
    let lookDirectionDegree = 0;
    let arrayWorld = [[],[]];

    function init() {

        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");

        if (!gl) {alert("WebGL isn't available");}

        //webgl configurations
        gl.viewport( 0, 0, canvas.width, canvas.height ); //delete
        gl.clearColor(0.2, 0.2, .2, 1 );

        gl.enable(gl.DEPTH_TEST);

        let fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        let vertexShader = new Shader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        shader = new ShaderProgram(gl, vertexShader.getter(), fragmentShader.getter());

        camera = new Camera(gl, shader.getProgram());

        optionListiners();

        let boardWeith = 30;
        let boardHight = 0.1;
        let boardLength = 30;
        let sideSizeX = 8;
        let sideSizeZ = 8;
        let objectsHights = 4;

        //colors
        let monoBlue = new MonochromeMaterial(gl, vec4(0,1, 1, 1.0), shader);
        let monoRed = new MonochromeMaterial(gl, vec4(1.0, 0.0, 0, 1.0), shader);
        let monoBlack = new MonochromeMaterial(gl, vec4(0, 0, 0, 1.0), shader);
        let monoWhite = new MonochromeMaterial(gl, vec4(1, 1, 1, 1.0), shader);
        let monoYellow = new MonochromeMaterial(gl, vec4(1, 1, 0, 1.0), shader);


        // translatons
        let centerTranslation = translate(0,0,0);
        let translation = translate(0,0,0);

        //transform
        let centerTransform = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
        let firstCubeTransform = mat4(1,0,0,-boardWeith/2+boardWeith/sideSizeX/2, 0,1,0,-3, 0,0,1,boardLength/2-boardLength/sideSizeZ/2, 0,0,0,1);
        let sphereTransform = mat4(1,0,0,0, 0,1,0,2, 0,0,1,0, 0,0,0,1);
        let cubeTransform = mat4(1,0,0,0, 0,1,0,2, 0,0,1,0, 0,0,0,1);
        let torusTransform = mat4(1,0,0,0, 0,1,0,2, 0,0,1,0, 0,0,0,1);
        let cylinderTransform = mat4(1,0,0,0, 0,1,0,2, 0,0,1,0, 0,0,0,1);
        let coneTransform = mat4(1,0,0,0, 0,1,0,2, 0,0,1,0, 0,0,0,1);

        //shapes
        let centerNode = new Sphere(gl, 0.5, shader.getProgram());
        let firstCubes = new Cuboid(gl, boardWeith/sideSizeX, boardHight, boardLength/sideSizeZ, shader.getProgram());
        let sphere = new Sphere(gl, objectsHights, shader.getProgram());
        let cube = new Cuboid(gl, 3, objectsHights, 2, shader.getProgram());
        let torus = new Torus(gl, objectsHights, 1, shader.getProgram());
        let cylinder = new Cylinder(gl, 2, objectsHights, shader.getProgram());
        let cone = new Cone(gl, 3, objectsHights, shader.getProgram());

        //center
        center = new GraphicsNode(gl, centerNode, monoBlue, centerTransform, monoBlack, translation);
        arrayWorld[0].push(new GraphicsNode(gl, firstCubes, monoWhite, firstCubeTransform, monoBlack, translation, center));


        //move item
        floor = new Floor(boardWeith, boardHight ,boardLength, sideSizeX, sideSizeZ, monoBlack, monoWhite, arrayWorld[0][0]);
        floor.createFloor(gl,shader);
        arrayWorld[1].push(floor);

        //nodes

        arrayWorld[1].push(new GraphicsNode(gl, sphere, monoYellow, sphereTransform, monoBlack, translation, arrayWorld[1][0].objectArray[4]));
        arrayWorld[1].push(new GraphicsNode(gl, cube, monoYellow, cubeTransform, monoBlack, translation, arrayWorld[1][0].objectArray[15]));
        arrayWorld[1].push(new GraphicsNode(gl, torus, monoYellow, torusTransform, monoBlack, translation, arrayWorld[1][0].objectArray[60]));
        arrayWorld[1].push(new GraphicsNode(gl, cylinder, monoYellow, cylinderTransform, monoBlack, translation, arrayWorld[1][0].objectArray[32]));
        arrayWorld[1].push(new GraphicsNode(gl, cone, monoYellow, coneTransform, monoBlack, translation, arrayWorld[1][0].objectArray[46]));


        arrayWorld[1][2].translate = mult(arrayWorld[1][2].translate, rotate(45,[1,1,1]));

        render();
    }

    function optionListiners(){
        let key = new Key();
        let changeObjects = new ChangeObjects();

        //buttons
        document.getElementById("persproj").checked = true;
        document.getElementById("mainForm").value = "1";
        document.getElementById("secoundaryForm").value = "1";
        document.getElementById("mainForm").onchange = changeObjects.mainNode;
        document.getElementById("mainwidth").onchange = changeObjects.mainNode;
        document.getElementById("mainheight").onchange = changeObjects.mainNode;
        document.getElementById("maindepth").onchange = changeObjects.mainNode;

        document.getElementById("secwidth").onchange = changeObjects.secoundChange;
        document.getElementById("secheight").onchange = changeObjects.secoundChange;
        document.getElementById("secdepth").onchange = changeObjects.secoundChange;

        document.getElementById("secoundaryForm").onchange = changeObjects.secoundChange;

        //camera
        document.getElementById("persproj").onchange = render;
        document.getElementById("orthproj").onchange = render; 
        
        //key input
        document.addEventListener('keydown', key.doKey, false);
    }
    
    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        shader.activate();
        camera.activate(document.getElementById("persproj").checked);

        center.draw();
        for(let i = 0; i < arrayWorld.length; i++){
            for(let j = 0; j < arrayWorld[i].length; j++){
                arrayWorld[i][j].draw();
            }
        }

        requestAnimationFrame(render);
    }

    function moveWorld(m){
        
        for(let i = 0; i < arrayWorld[0].length; i++){
            arrayWorld[0][i].updateLocalMatrix(m);
        }
    }

    function rotateWorldY(degree){
        console.log(degree);
        arrayWorld[0][0].translate = mult(arrayWorld[0][0].translate, rotate(degree,[0,1,0]));
        
        for(let i = 0; i < arrayWorld[0].length; i++){
            rotateObjectY(arrayWorld[0][i],degree);
        }
    } 

    function rotateObjectY(item,degree){
        let a = item.localMatrix[2][3]; //z
        let b = item.localMatrix[0][3]; //x
        let hyp = Math.sqrt(a*a + b*b);
        let angle = Math.atan(a/b) * (180/Math.PI);

        if(a == 0 && b==0){
            a=0;
            b=0;
        }
        else if(a > 0 && b == 0){ // 90
            if(degree > 0){
                angle = -90 + degree;
                b = ( hyp * Math.cos(angle * (Math.PI/180) ));
            }else if(degree < 0){
                angle = angle + degree;
                b =  -hyp * Math.cos(angle * (Math.PI/180) );
            }
        }else if(a < 0 && b == 0){ // -90

            if(degree > 0){
                angle = -90 + degree;
                b = -hyp * Math.cos(angle * (Math.PI/180) );
            }else if(degree < 0){
                angle = angle + degree;
                b = -hyp * Math.cos(angle * (Math.PI/180) );
            }
        }
        else{
           if(angle - degree < -90){
                angle = 90 + (angle -degree +90);
                if(b>0){
                    b = -(hyp * Math.cos(angle * (Math.PI/180) ));
                }else{
                    b = hyp * Math.cos(angle * (Math.PI/180) );
                }
            }
            else{
                angle -=degree;
            }

            if(b > 0){
                b = hyp * Math.cos(angle * (Math.PI/180) );
                a = hyp * Math.sin(angle * (Math.PI/180));
            }
            else if(b==0){
                if(a > 0){
                    a = hyp * Math.sin(angle * (Math.PI/180));
                }
                if(a > 0){
                    a = -(hyp * Math.sin(angle * (Math.PI/180)));
                }
                b = -(hyp * Math.cos(angle * (Math.PI/180) ));
            }
            else{
                b = -(hyp * Math.cos(angle * (Math.PI/180) ));
                a = -(hyp * Math.sin(angle * (Math.PI/180)));
            }
        }
        item.localMatrix[2][3] = a;
        item.localMatrix[0][3] = b;
        for(let i = 0; i < item.children.length; i++){
            rotateObjectY(item.children[i],degree);
        }
    }

    window.onload = init;
    
</script>
</head>
<body>
        <h2>A Cube with Basic Lighting</h2>

    <p id=message>Use arrow keys, PageUp, and PageDown to rotate the cube.<br>
    Home or Return key resets rotations to zero.</p>

    <p>
    <label><input type="radio" name="projectionType" id="persproj" value="perspective">Perspective projection</label>
    <label><input type="radio" name="projectionType" id="orthproj" value="orthogonal" style="margin-left:1cm">Orthogonal projection</label>
    <label><b>Main form:</b>&nbsp;<select id="mainForm">
        <option value="1">square</option>
        <option value="2">sphere</option>
        <option value="3">cone</option>
        <option value="4">torus</option>
        <option value="5">cylinder</option>
        <option value="6">Star</option>

    </select></label>
    <label><b>width<input type="number"  id="mainwidth" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>height<input type="number"  id="mainheight" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>depth<input type="number" id="maindepth" value="0.5" min="0.1" step="0.1"></b></label> 
    <style>
        input {
            resize: horizontal;
            width: 40px;
        }
    </style>    

    <label><b>stastionary form: </b>&nbsp;<select id="secoundaryForm">
        <option value="0">random</option>
        <option value="1">square</option>
        <option value="2">sphere</option>
        <option value="3">cone</option>
        <option value="4">torus</option>
        <option value="5">cylinder</option>
        <option value="6">Star</option>


    </select></label>
    <label><b>width<input type="number"  id="secwidth" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>height<input type="number"  id="secheight" value="0.5" min="0.1" step="0.1"></b></label> 
    <label><b>depth<input type="number"  id="secdepth" value="0.5" min="0.1" step="0.1"></b></label> 
    <style>
        input {
            resize: horizontal;
            width: 40px;
        }
    </style>    
    </p>

    <noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

    <div id="canvas-holder">
    <canvas width=1500px height=800px id="webglcanvas" style="background-color:rgb(0, 0, 0)"></canvas>
    </div>

</body>
</html>