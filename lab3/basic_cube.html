<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
    <title>Laboration 3</title>

    <style>
        body {
            background-color: #ffffff;
        }
    </style>
    
    <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec4 vertexPos;
    uniform mat4 cMatrix;
    uniform mat4 vMatrix;
    uniform mat4 pMatrix;

    void main()
    {
      gl_Position = pMatrix * vMatrix * cMatrix * vertexPos;
    }

    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_Color;

    void main() {
        gl_FragColor = u_Color;
    }
    </script>

    <script type="text/javascript" src="gl_matrix.js"></script>
    <script type="text/javascript" src="MV.js"></script>
    <script type="text/javascript" src="Classes/mesh.js"></script>
    <script type="text/javascript" src="Classes/shader.js"></script>
    <script type="text/javascript" src="Classes/shaderProgram.js"></script>
    <script type="text/javascript" src="Classes/matrial.js"></script>
    <script type="text/javascript" src="Classes/graphicsNode.js"></script>
    <script type="text/javascript" src="Classes/monochromeMaterial.js"></script>
    <script type="text/javascript" src="camera.js"></script>

    <script>
        //id vertex shader and id fragmen shader is the shaders we have
      
    var canvas;
    var gl;
    var nodes = [];
    var greenNode;
    var greenNodeTransform = mat4(1,0,0,-3, 0,1,0,1, 0,0,1,2, 0,0,0,1);
    var camera;
    var shader;
    var vertices = [
        vec4(-0.2, -0.2, 0.5, 1),
        vec4(-0.2, 0.2, 0.5, 1),
        vec4(0.2, 0.2, 0.5, 1),
        vec4(0.2, -0.2, 0.5, 1),
        vec4(0.2, -0.2, -0.5, 1),
        vec4(0.2, 0.2, -0.5, 1),
        vec4(-0.2, 0.2, -0.5, 1),
        vec4(-0.2, -0.2, -0.5, 1)
    ];
    var indices = [
        0, 1, 2, 
        2, 3, 0, 
        0, 1, 6, 
        6, 7, 0, 
        1, 6, 2, 
        2, 6, 5, 
        7, 6, 5, 
        5, 7, 4, 
        5, 4, 3, 
        3, 2, 5, 
        7, 4, 3, 
        7, 3, 0
    ];

    function init() {
    canvas = document.getElementById("gl-canvas");
    gl = canvas.getContext("webgl2");

    if (!gl) {alert("WebGL isn't available");}

    //webgl configurations
    gl.viewport( 0, 0, canvas.width, canvas.height );
    gl.clearColor(0.8, 1, 1, 1.0 );

    gl.enable(gl.DEPTH_TEST);

    var fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, "fragment-shader");
    var vertexShader = new Shader(gl, gl.VERTEX_SHADER, "vertex-shader");
    shader = new ShaderProgram(gl, vertexShader.getter(), fragmentShader.getter());
    //shader.activateShader();

    camera = new Camera(gl, shader.getProgram());

    document.addEventListener("keydown", doKey, false);

    var mesh = new Mesh(gl, vertices, indices, shader.getProgram());
    var monoBlue = new MonochromeMaterial(gl, vec4(0,1, 1, 1.0), shader);
    var monoGreen = new MonochromeMaterial(gl, vec4(0.0, 1.0, 0, 1.0), shader);

    greenNode = new GraphicsNode(gl, mesh, monoGreen, greenNodeTransform);

    var max = 10;
    var min = -10;
    var maxZ = 10;
    var minZ = -40
    for (var i = 0; i <= 60; i++) {
        var x = Math.floor(Math.random() * (max - min)) + min;
        var y = Math.floor(Math.random() * (max - min)) + min;
        var z = Math.floor(Math.random() * (maxZ - minZ)) + minZ;
        var transform = mat4(1,0,0,x, 0,1,0,y, 0,0,1,z, 0,0,0,1);
        nodes.push(new GraphicsNode(gl, mesh, monoBlue, transform));
    }

    //camera.activate();

    render();
    }

    function render() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    shader.activate();
    camera.activate();

    greenNode.draw();

    for(var i = 0; i < nodes.length; i++) {
        nodes[i].draw();
    }
    }

    window.addEventListener('keydown', function(event) {
        //increase y
        if(event.keyCode == 87) { //W
            greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,0.1, 0,0,0,0, 0,0,0,0));
            greenNode.updateTransform(greenNodeTransform);

        //decrease x
        } else if(event.keyCode == 65) { //A
        greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,-0.1, 0,0,0,0, 0,0,0,0, 0,0,0,0));
        greenNode.updateTransform(greenNodeTransform);

        //decrease y
        } else if(event.keyCode == 83) { //S
        greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,-0.1, 0,0,0,0, 0,0,0,0));
        greenNode.updateTransform(greenNodeTransform);

        //increase x
        } else if(event.keyCode == 68) { //D
        greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0.1, 0,0,0,0, 0,0,0,0, 0,0,0,0));
        greenNode.updateTransform(greenNodeTransform);

        //decrease z
        } else if(event.keyCode == 69) { //E
        greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,0, 0,0,0,-0.1, 0,0,0,0));
        greenNode.updateTransform(greenNodeTransform);
        //console.log(testTransform[2][3])

        //increase z
        } else if(event.keyCode == 67) { //C
        greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,0, 0,0,0,0.1, 0,0,0,0));
        greenNode.updateTransform(greenNodeTransform);
        }

        //render with updated position for green cube
        render();
    });
    
    function doKey(evt) {
        let rotationChanged = true;
        switch (evt.keyCode) {
            case 37:
                greenGraphicNode.update([[0,0,0,-0.05], [0,0,0,0], [0,0,0,0], [0,0,0,1]]) 
                break;        // left arrow
            case 39:
                greenGraphicNode.update([[0,0,0,0.05], [0,0,0,0], [0,0,0,0], [0,0,0,1]]) 
                break;       // right arrow
            case 38: 
                greenGraphicNode.update([[0,0,0,0], [0,0,0,0.05], [0,0,0,0], [0,0,0,1]]) 
                break;        // up arrow
            case 40:
                greenGraphicNode.update([[0,0,0,0], [0,0,0,-0.05], [0,0,0,0], [0,0,0,1]]) 
                break;         // down arrow
            case 33: 
                greenGraphicNode.update([[0,0,0,0], [0,0,0,0], [0,0,0,-0.05], [0,0,0,1]]) 
                break;         // PageUp
            case 34:        
                greenGraphicNode.update([[0,0,0,0], [0,0,0,0], [0,0,0,0.05], [0,0,0,1]]) 
                break;// PageDown
            case 13:                                // return key
            case 36: rotateX = rotateY = rotateZ = 0; break;  // home key
            default: rotationChanged = false;
        }
        if (rotationChanged) {
                evt.preventDefault();
                draw();
        }
    }
    window.onload = init;
    

</script>
</head>
<body>
        <h2>A Cube with Basic Lighting</h2>

    <p id=message>Use arrow keys, PageUp, and PageDown to rotate the cube.<br>
    Home or Return key resets rotations to zero.</p>

    <p>
    <label><input type="radio" name="projectionType" id="persproj" value="perspective">Perspective projection</label>
    <label><input type="radio" name="projectionType" id="orthproj" value="orthogonal" style="margin-left:1cm">Orthogonal projection</label>
    </p>

    <noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

    <div id="canvas-holder">
    <canvas width=1700px height=900px id="gl-canvas" style="background-color:red"></canvas>
    </div>

</body>
</html>