<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
<title>Lit Cube Using glMatrix and WebGL</title>
<style>
    body {
        background-color: #EEEEEE;
    }
</style>

<!--
    Shows a cube drawn using very basic lighting:  A white
    light shining in the direction of the negative z-axis,
    in eye coordinates, with diffuse color only.
-->


<script src="gl_matrix.js"></script>
<script src="Classes/mesh.js"></script>
<script src="Classes/shader.js"></script>
<script src="Classes/shaderProgram.js"></script>
<script src="Classes/matrial.js"></script>
<script src="Classes/graphicsNode.js"></script>
<script src="Classes/monochromeMaterial.js"></script>
<script src="Classes/cuboid.js"></script>
<script src="camera.js"></script>


<script>
 
"use strict";


const vertexShaderSource = `
    attribute vec3 a_coords;
    uniform mat4 modelviewProjection;
    uniform bool lit;
    uniform vec3 normal;
    uniform mat3 normalMatrix;
    uniform vec4 color;
    varying vec4 v_color;
    void main() {
        vec4 coords = vec4(a_coords,1.0);
        gl_Position = modelviewProjection * coords;
        if (lit) {
           vec3 N = normalize(normalMatrix*normal);  // Transformed unit normal
           float dotProduct = abs(N.z);  // cosine of angle of incidence of light with surface
           v_color = vec4( dotProduct*color.rgb, color.a );
        }
        else {
            v_color = color;
        }
    }`;


const fragmentShaderSource = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
       precision highp float;
    #else
       precision mediump float;
    #endif
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }`;

let gl;   // The webgl context.
let greenNodeTransform = [[1,0,0,0],[ 0,1,0,0],[ 0,0,1,0],[ 0,0,0,1]];
var greenGraphicNode;
let shaderProgram;
let nodes=[];
var camera;

let a_coords_loc;       // Location of the a_coords attribute variable in the shader program.
let a_coords_buffer;    // Buffer to hold the values for a_coords.
let u_color;            // Location of the uniform vec4 specifying a color for the primitive
let u_modelviewProj;    // Location of the uniform mat4 representing the modelview and projection transformation
let u_lit;              // Location of the uniform bool that says whether lighting should be applied
let u_normal;           // Location of the uniform vec3 representing the normal vector
let u_normalMatrix;     // Location of the unifrom mat3 representing the transform to be applied to normal vectors

const projection = mat4.create();    // projection matrix
const modelview = mat4.create();     // modelview matrix
const modelviewProj = mat4.create(); // combined transformation matrix
const normalMatrix = mat3.create(); // matrix, derived from modelview matrix, for transforming normal vectors

let verticesGreen = [
    [-0.2, -0.2, 0.2, 1],
    [-0.2, 0.2, 0.2, 1],
    [0.2, 0.2, 0.2, 1],
    [0.2, -0.2, 0.2, 1],
    [0.2, -0.2, -0.2, 1],
    [0.2, 0.2, -0.2, 1],
    [-0.2, 0.2, -0.2, 1],
     [-0.2, -0.2, -0.2, 1]
    
]

let verticesOverall = [
    [-0.2, -0.2, 0.5, 1],
    [-0.2, 0.2, 0.5, 1],
    [0.2, 0.2, 0.5, 1],
    [0.2, -0.2, 0.5, 1],
    [0.2, -0.2, -0.5, 1],
    [0.2, 0.2, -0.5, 1],
    [-0.2, 0.2, -0.5, 1],
    [-0.2, -0.2, -0.5, 1]
]

let indices = [
  0, 1, 2, 
  2, 3, 0, 
  0, 1, 6, 
  6, 7, 0, 
  1, 6, 2, 
  2, 6, 5, 
  7, 6, 5, 
  5, 7, 4, 
  5, 4, 3, 
  3, 2, 5, 
  7, 4, 3, 
  7, 3, 0
];

/* Draws a WebGL primitive.  The first parameter must be one of the constants
 * that specifiy primitives:  gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP,
 * gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN.  The second parameter must
 * be an array of 4 numbers in the range 0.0 to 1.0, giving the RGBA color of
 * the color of the primitive.  The third parameter must be an array of numbers.
 * The length of the array must be amultiple of 3.  Each triple of numbers provides
 * xyz-coords for one vertex for the primitive.  This assumes that u_color is the
 * location of a color uniform in the shader program, a_coords_loc is the location of
 * the coords attribute, and a_coords_buffer is a VBO for the coords attribute.
 */
function drawPrimitive( primitiveType, color, vertices ) {
     gl.enableVertexAttribArray(a_coords_loc);
     gl.bindBuffer(gl.ARRAY_BUFFER,a_coords_buffer);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STREAM_DRAW);
     gl.uniform4fv(u_color, color);
     gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
     gl.drawArrays(primitiveType, 0, vertices.length/3);
}


/* Draws a colored cube, along with a set of coordinate axes.
 * (Note that the use of the above drawPrimitive function is not an efficient
 * way to draw with WebGL.  Here, the geometry is so simple that it doesn't matter.)
 */
function render() { 
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    shaderProgram.activate();
    
    /* Set the value of projection to represent the projection transformation. */

    /*This is to determain the size of the board*/
    if (document.getElementById("persproj").checked) {
        mat4.perspective(projection, Math.PI/5, 1, 4, 80);
    }
    else {
        mat4.ortho(projection,-2, 2, -2, 2, 4, 8);
    }
    
    /* Set the value of modelview to represent the viewing transform. */

    mat4.lookAt(modelview, [0,2,6], [0,0,0], [0,1,0]);

    
    /* Multiply the modelview and projection transformss to get the combined
    transform, and send it to the shader program. */
    
    mat4.multiply( modelviewProj, projection, modelview );
    gl.uniformMatrix4fv(u_modelviewProj, false, modelviewProj );
    
    /* Get the matrix for transforming normal vectors from the modelview matrix.*/ 
    
    mat3.normalFromMat4(normalMatrix, modelview);
    gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);


    greenGraphicNode.draw();
}


/**
 *  An event listener for the keydown event.  It is installed by the init() function.
 *  The arrow keys, PageUp, and PageDown will rotate the cube by modifying the
 *  modeling transformation.  Home and Return key resets the modeling transform
 *  to the identity.
 */
function doKey(evt) {
    let rotationChanged = true;
    switch (evt.keyCode) {
        case 37:
            greenGraphicNode.update([[0,0,0,-0.05], [0,0,0,0], [0,0,0,0], [0,0,0,1]]) 
            break;        // left arrow
        case 39:
            greenGraphicNode.update([[0,0,0,0.05], [0,0,0,0], [0,0,0,0], [0,0,0,1]]) 
            break;       // right arrow
        case 38: 
            greenGraphicNode.update([[0,0,0,0], [0,0,0,0.05], [0,0,0,0], [0,0,0,1]]) 
            break;        // up arrow
        case 40:
            greenGraphicNode.update([[0,0,0,0], [0,0,0,-0.05], [0,0,0,0], [0,0,0,1]]) 
            break;         // down arrow
        case 33: 
            greenGraphicNode.update([[0,0,0,0], [0,0,0,0], [0,0,0,-0.05], [0,0,0,1]]) 
            break;         // PageUp
        case 34:        
            greenGraphicNode.update([[0,0,0,0], [0,0,0,0], [0,0,0,0.05], [0,0,0,1]]) 
            break;// PageDown
        case 13:                                // return key
        case 36: rotateX = rotateY = rotateZ = 0; break;  // home key
        default: rotationChanged = false;
    }
    if (rotationChanged) {
              evt.preventDefault();
              render();
    }
}


/**
 * initialization function that will be called when the page has loaded.
 */
function init() {
    try {
        let canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");
        if ( ! gl ) {
            throw "Browser does not support WebGL";
        }
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
        return;
    }
    gl.clearColor(0.7,0.7,0.7,1);
    gl.enable(gl.DEPTH_TEST);

    try {
        var obj1 = new Shader();
        var obj2 = new Shader();
        shaderProgram = new ShaderProgram();
        
        obj1.combindShaders(gl,  vertexShaderSource, gl.VERTEX_SHADER )
        obj2.combindShaders(gl,  fragmentShaderSource, gl.FRAGMENT_SHADER)
        shaderProgram.combineShaders(gl, obj1.getter(), obj2.getter());

        shaderProgram.activate()
        let prog = shaderProgram.getProgram();
        a_coords_loc =  gl.getAttribLocation(prog, "a_coords");
        u_modelviewProj = gl.getUniformLocation(prog, "modelviewProjection");
        u_color =  gl.getUniformLocation(prog, "color");
        u_lit =  gl.getUniformLocation(prog, "lit");
        u_normal =  gl.getUniformLocation(prog, "normal");
        u_normalMatrix =  gl.getUniformLocation(prog, "normalMatrix");
        a_coords_buffer = gl.createBuffer();
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context:" + e.message + "</p>";
        return;
    }
    camera = new Camera(gl, shaderProgram.getProgram());


    document.getElementById("persproj").checked = true;
    document.getElementById("persproj").onchange = render;
    document.getElementById("orthproj").onchange = render;
    document.addEventListener("keydown", doKey, false);

    let mesh = new Mesh(gl, verticesGreen, indices, shaderProgram.getProgram());
    let chromeRed = new MonochromeMaterial(gl, [0.8, 0.0, 0.4, 1.0], shaderProgram);
    let chromeGreen = new MonochromeMaterial(gl, [0.0, 1.0, 0.0, 1.0], shaderProgram);
    
    greenGraphicNode = new GraphicsNode(gl, mesh, chromeGreen , greenNodeTransform);

    /*
    var max = 10;
    var min = -10;
    var maxZ = 10;
    var minZ = -40
    for (var i = 0; i <= 60; i++) {
        var x = Math.floor(Math.random() * (max - min)) + min;
        var y = Math.floor(Math.random() * (max - min)) + min;
        var z = Math.floor(Math.random() * (maxZ - minZ)) + minZ;
        var transform =[[1,0,0,x],[ 0,1,0,y],[ 0,0,1,z],[ 0,0,0,1]];
        nodes.push(new GraphicsNode(gl, mesh, chromeRed, transform));

    }
    */
    render();
}


window.onload = init;

</script>
</head>
<body>

<h2>A Cube with Basic Lighting</h2>

<p id=message>Use arrow keys, PageUp, and PageDown to rotate the cube.<br>
Home or Return key resets rotations to zero.</p>

<p>
  <label><input type="radio" name="projectionType" id="persproj" value="perspective">Perspective projection</label>
  <label><input type="radio" name="projectionType" id="orthproj" value="orthogonal" style="margin-left:1cm">Orthogonal projection</label>
</p>

<noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

<div id="canvas-holder">
   <canvas width=600 height=600 id="webglcanvas" style="background-color:red"></canvas>
</div>


</body>
</html>

