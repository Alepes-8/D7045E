<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
    <title>Laboration 3</title>

    <style>
        body {
            background-color: #ffffff;
        }
    </style>
    
    <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec4 vertexPos;
    uniform mat4 cMatrix;
    uniform mat4 vMatrix;
    uniform mat4 pMatrix;

    void main()
    {
      gl_Position = pMatrix * vMatrix * cMatrix * vertexPos;
    }

    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_Color;

    void main() {
        gl_FragColor = u_Color;
    }
    </script>

    <script type="text/javascript" src="gl_matrix.js"></script>
    <script type="text/javascript" src="MV.js"></script>
    <script type="text/javascript" src="Classes/mesh.js"></script>
    <script type="text/javascript" src="Classes/shader.js"></script>
    <script type="text/javascript" src="Classes/shaderProgram.js"></script>
    <script type="text/javascript" src="Classes/matrial.js"></script>
    <script type="text/javascript" src="Classes/graphicsNode.js"></script>
    <script type="text/javascript" src="Classes/monochromeMaterial.js"></script>
    <script type="text/javascript" src="camera.js"></script>

    <script>
        //id vertex shader and id fragmen shader is the shaders we have
      
    let canvas;
    let gl;
    let nodes = [];
    let greenNode;
    let greenNodeTransform = mat4(1,0,0,0, 0,1,0,-0.5, 0,0,1,8, 0,0,0,1);
    let test = [[1,0,0,0],[0,1,0,-0.5],[0,0,1,8],[0,0,0,1]];
    let camera;
    let shader;
    let vertices = [
        [-0.2, -0.2, 0.5, 1],
        [-0.2, 0.2, 0.5, 1],
        [0.2, 0.2, 0.5, 1],
        [0.2, -0.2, 0.5, 1],
        [0.2, -0.2, -0.5, 1],
        [0.2, 0.2, -0.5, 1],
        [-0.2, 0.2, -0.5, 1],
        [-0.2, -0.2, -0.5, 1]
    ];

    let indices = [
        0, 1, 2, 
        2, 3, 0, 
        0, 1, 6, 
        6, 7, 0, 
        1, 2, 5,
        5, 6, 1, 
        2, 5, 4,
        4, 3, 2,
        3, 0, 7,
        7, 4, 3,
        4, 5, 6,
        6, 7, 4
    ];

    function init() {

        canvas = document.getElementById("gl-canvas");
        gl = canvas.getContext("webgl2");

        if (!gl) {alert("WebGL isn't available");}

        //webgl configurations
        gl.viewport( 0, 0, canvas.width, canvas.height );
        gl.clearColor(0.8, 1, 1, 1.0 );

        gl.enable(gl.DEPTH_TEST);

        let fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, "fragment-shader");
        let vertexShader = new Shader(gl, gl.VERTEX_SHADER, "vertex-shader");
        shader = new ShaderProgram(gl, vertexShader.getter(), fragmentShader.getter());
        //shader.activateShader();

        camera = new Camera(gl, shader.getProgram());

        document.getElementById("persproj").checked = true;
        document.getElementById("persproj").onchange = render;
        document.getElementById("orthproj").onchange = render;       
        document.addEventListener('keydown', doKey, false);

        let mesh = new Mesh(gl, vertices, indices, shader.getProgram());
        let monoBlue = new MonochromeMaterial(gl, [0,1, 1, 1.0], shader);
        let monoGreen = new MonochromeMaterial(gl, [0.0, 1.0, 0, 1.0], shader);
        let monoBlack = new MonochromeMaterial(gl, [0, 0, 0, 1.0], shader);

        greenNode = new GraphicsNode(gl, mesh, monoGreen, greenNodeTransform, monoBlack);

        let max = 10;
        let min = -10;
        let maxZ = 10;
        let minZ = -40
        for (let i = 0; i <= 60; i++) {
            let x = Math.floor(Math.random() * (max - min)) + min;
            let y = Math.floor(Math.random() * (max - min)) + min;
            let z = Math.floor(Math.random() * (maxZ - minZ)) + minZ;
            let transform = mat4(1,0,0,x, 0,1,0,y, 0,0,1,z, 0,0,0,1);
            nodes.push(new GraphicsNode(gl, mesh, monoBlue, transform,monoBlack));
        }


        render();
    }

    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        shader.activate();
        camera.activate(document.getElementById("persproj").checked);

        greenNode.draw();

        for(let i = 0; i < nodes.length; i++) {
            nodes[i].draw();
        }
    }

    
    function doKey(evt) {
        let movementChange = true;
        switch (evt.keyCode) {
            case 37:
                greenNode.updateTransform(mat4(0,0,0,-0.1, 0,0,0,0, 0,0,0,0, 0,0,0,0));
                break;        // left arrow
            case 39:
                
            greenNode.updateTransform( mat4(0,0,0,0.1, 0,0,0,0, 0,0,0,0, 0,0,0,0));
                break;       // right arrow
            case 38: 
                
                greenNode.updateTransform( mat4(0,0,0,0, 0,0,0,0.1, 0,0,0,0, 0,0,0,0));
                break;        // up arrow
            case 40:
                
                greenNode.updateTransform(mat4(0,0,0,0, 0,0,0,-0.1, 0,0,0,0, 0,0,0,0));
                break;         // down arrow
            case 33: 
            
                greenNode.updateTransform(mat4(0,0,0,0, 0,0,0,0, 0,0,0,-0.1, 0,0,0,0));
                break;         // PageUp
            case 34:        
            
                greenNode.updateTransform(mat4(0,0,0,0, 0,0,0,0, 0,0,0,0.1, 0,0,0,0)); 
                break;// PageDown
            case 13:                                // return key
            case 36: rotateX = rotateY = rotateZ = 0; break;  // home key
            default: movementChange = false;
        }
        if (movementChange) {
                evt.preventDefault();
                render();
        }
    }
    /*
    function doKey(evt) {
        let movementChange = true;
        switch (evt.keyCode) {
            case 37:
                greenNode.updateTransform([[0,0,0,-0.1], [0,0,0,0], [0,0,0,0], [0,0,0,1]]);
                break;        // left arrow
            case 39:
            greenNode.updateTransform( [[0,0,0,0.1], [0,0,0,0], [0,0,0,0], [0,0,0,1]]);
                break;       // right arrow
            case 38: 
                greenNode.updateTransform( [[0,0,0,0], [0,0,0,0.1], [0,0,0,0], [0,0,0,1]]);
                break;        // up arrow
            case 40:
                greenNode.updateTransform([[0,0,0,0], [0,0,0,-0.1], [0,0,0,0], [0,0,0,1]]);
                break;         // down arrow
            case 33: 
                greenNode.updateTransform([[0,0,0,0], [0,0,0,0], [0,0,0,-0.1], [0,0,0,1]]);
                break;         // PageUp
            case 34:        
                greenNode.updateTransform([[0,0,0,0], [0,0,0,0], [0,0,0,0.1], [0,0,0,1]]); 
                break;// PageDown
            case 13:                                // return key
            case 36: rotateX = rotateY = rotateZ = 0; break;  // home key
            default: movementChange = false;
        }
        if (movementChange) {
                evt.preventDefault();
                render();
        }
    }*/
    window.onload = init;
    

</script>
</head>
<body>
        <h2>A Cube with Basic Lighting</h2>

    <p id=message>Use arrow keys, PageUp, and PageDown to rotate the cube.<br>
    Home or Return key resets rotations to zero.</p>

    <p>
    <label><input type="radio" name="projectionType" id="persproj" value="perspective">Perspective projection</label>
    <label><input type="radio" name="projectionType" id="orthproj" value="orthogonal" style="margin-left:1cm">Orthogonal projection</label>
    </p>

    <noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

    <div id="canvas-holder">
    <canvas width=1700px height=900px id="gl-canvas" style="background-color:red"></canvas>
    </div>

</body>
</html>