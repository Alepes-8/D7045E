<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
    <title>Laboration 3</title>

    <style>
        body {
            background-color: #ffffff;
        }
    </style>
    
    <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec4 vertexPos;
    uniform mat4 cMatrix;
    uniform mat4 vMatrix;
    uniform mat4 pMatrix;

    void main()
    {
      gl_Position = pMatrix * vMatrix * cMatrix * vertexPos;
    }

    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_Color;

    void main() {
        gl_FragColor = u_Color;
    }
    </script>

    <script type="text/javascript" src="gl_matrix.js"></script>
    <script type="text/javascript" src="MV.js"></script>
    <script type="text/javascript" src="Classes/mesh.js"></script>
    <script type="text/javascript" src="Classes/shader.js"></script>
    <script type="text/javascript" src="Classes/shaderProgram.js"></script>
    <script type="text/javascript" src="Classes/matrial.js"></script>
    <script type="text/javascript" src="Classes/graphicsNode.js"></script>
    <script type="text/javascript" src="Classes/monochromeMaterial.js"></script>
    <script type="text/javascript" src="camera.js"></script>

    <script>
        //id vertex shader and id fragmen shader is the shaders we have
      
    var canvas;
    var gl;
    var nodes = [];
    var greenNode;
    var greenNodeTransform = mat4(1,0,0,0, 0,1,0,-0.5, 0,0,1,8, 0,0,0,1);
    var camera;
    var shader;
    var vertices = [
        vec4(-0.2, -0.2, 0.5, 1),
        vec4(-0.2, 0.2, 0.5, 1),
        vec4(0.2, 0.2, 0.5, 1),
        vec4(0.2, -0.2, 0.5, 1),
        vec4(0.2, -0.2, -0.5, 1),
        vec4(0.2, 0.2, -0.5, 1),
        vec4(-0.2, 0.2, -0.5, 1),
        vec4(-0.2, -0.2, -0.5, 1)
    ];

    var indices = [
        0, 1, 2, 
        2, 3, 0, 
        0, 1, 6, 
        6, 7, 0, 
        1, 2, 5,
        5, 6, 1, 
        2, 5, 4,
        4, 3, 2,
        3, 0, 7,
        7, 4, 3,
        4, 5, 6,
        6, 7, 4
    ];

    function init() {
        canvas = document.getElementById("gl-canvas");
        gl = canvas.getContext("webgl2");

        if (!gl) {alert("WebGL isn't available");}

        //webgl configurations
        gl.viewport( 0, 0, canvas.width, canvas.height );
        gl.clearColor(0.8, 1, 1, 1.0 );

        gl.enable(gl.DEPTH_TEST);

        var fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, "fragment-shader");
        var vertexShader = new Shader(gl, gl.VERTEX_SHADER, "vertex-shader");
        shader = new ShaderProgram(gl, vertexShader.getter(), fragmentShader.getter());
        //shader.activateShader();

        camera = new Camera(gl, shader.getProgram());

        document.addEventListener('keydown', doKey, false);

        let mesh = new Mesh(gl, vertices, indices, shader.getProgram());
        var monoBlue = new MonochromeMaterial(gl, vec4(0,1, 1, 1.0), shader);
        var monoGreen = new MonochromeMaterial(gl, vec4(0.0, 1.0, 0, 1.0), shader);
        var monoBlack = new MonochromeMaterial(gl, vec4(0, 0, 0, 1.0), shader);

        greenNode = new GraphicsNode(gl, mesh, monoGreen, greenNodeTransform, monoBlack);

        var max = 10;
        var min = -10;
        var maxZ = 10;
        var minZ = -40
        for (var i = 0; i <= 60; i++) {
            var x = Math.floor(Math.random() * (max - min)) + min;
            var y = Math.floor(Math.random() * (max - min)) + min;
            var z = Math.floor(Math.random() * (maxZ - minZ)) + minZ;
            var transform = mat4(1,0,0,x, 0,1,0,y, 0,0,1,z, 0,0,0,1);
            nodes.push(new GraphicsNode(gl, mesh, monoBlue, transform,monoBlack));
        }

        //camera.activate();

        render();
    }

    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        shader.activate();
        camera.activate();

        greenNode.draw();

        for(var i = 0; i < nodes.length; i++) {
            nodes[i].draw();
        }
    }

    function doKey(evt) {
        let movementChange = true;
        switch (evt.keyCode) {
            case 37:
                greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,-0.1, 0,0,0,0, 0,0,0,0, 0,0,0,0));
                greenNode.updateTransform(greenNodeTransform);
                break;        // left arrow
            case 39:
                greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0.1, 0,0,0,0, 0,0,0,0, 0,0,0,0));
            greenNode.updateTransform(greenNodeTransform);
                break;       // right arrow
            case 38: 
                greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,0.1, 0,0,0,0, 0,0,0,0));
                greenNode.updateTransform(greenNodeTransform);
                break;        // up arrow
            case 40:
                greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,-0.1, 0,0,0,0, 0,0,0,0));
                greenNode.updateTransform(greenNodeTransform);
                break;         // down arrow
            case 33: 
                greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,0, 0,0,0,-0.1, 0,0,0,0));
                greenNode.updateTransform(greenNodeTransform);
                break;         // PageUp
            case 34:        
                greenNodeTransform = add(greenNodeTransform, mat4(0,0,0,0, 0,0,0,0, 0,0,0,0.1, 0,0,0,0));
                greenNode.updateTransform(greenNodeTransform); 
                break;// PageDown
            case 13:                                // return key
            case 36: rotateX = rotateY = rotateZ = 0; break;  // home key
            default: movementChange = false;
        }
        if (movementChange) {
                evt.preventDefault();
                render();
        }
    }
    window.onload = init;
    

</script>
</head>
<body>
        <h2>A Cube with Basic Lighting</h2>

    <p id=message>Use arrow keys, PageUp, and PageDown to rotate the cube.<br>
    Home or Return key resets rotations to zero.</p>

    <p>
    <label><input type="radio" name="projectionType" id="persproj" value="perspective">Perspective projection</label>
    <label><input type="radio" name="projectionType" id="orthproj" value="orthogonal" style="margin-left:1cm">Orthogonal projection</label>
    </p>

    <noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

    <div id="canvas-holder">
    <canvas width=1700px height=900px id="gl-canvas" style="background-color:red"></canvas>
    </div>

</body>
</html>